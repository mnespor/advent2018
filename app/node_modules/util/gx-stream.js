'use strict'

const R = require('ramda')

const iteratorKey = Symbol('iterator')
const xfKey = Symbol('xf')
const predicateKey = Symbol('predicate')

function of(iterator) {
    return {
        take(n) {
            const result = []
            for (let i = 0; i < n; i++) {
                const item = this.next()
                if (item.done) {
                    return result
                }

                result.push(item.value)
            }

            return result
        },
        map(f) {
            return {
                ...of(this),
                [xfKey]: f
            }
        },
        reduce() {
            throw new Error('not implemented')
        },
        filter(predicate) {
            return {
                ...of(this),
                [predicateKey]: predicate
            }
        },
        // returns the next value of the iterator, filtered by predicate and
        // transformed by xf.
        next() {
            let base = null
            while(true) {
                base = iterator.next()
                if (base.done) {
                    return base
                }

                const value = this[xfKey](base.value)
                if (this[predicateKey](value)) {
                    return {
                        ...base,
                        value
                    }
                }
            }
        },
        *[Symbol.iterator]() {
            return this
        },
        [xfKey]: R.identity,
        [predicateKey]: R.always(true)
    }
}

module.exports = {
    /**
     * Wraps an iterator in an object that has collection methods for Ramda to
     * delegate to. Includes `take`, `map`, `filter`, and `reduce`. `reduce`
     * handles `R.reduced` for early termination.
     *
     * `take`, `reduce`, and `next` consume the underlying iterator.
     * @param {Object} iterator Any object that conforms to Iterator
     * @returns {Object} An iterator wrapper that Ramda can delegate to
     */
    of
}
